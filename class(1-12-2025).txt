Time and space complexity:
1.Iterative approach:
  Frequency count method
2.Recursion approach:
  1.anchor step
  2.Recursive step
  
  
  Time complexity of a recursive program is nothing but the number function calls
  
  one function call------>1unit
  two function call------>2 unit
  
  
  n function------>n unit 
  
  def fun1():
     print("hello")
  fun1()------------>T(n)=O(1)
  
  
  def fun2():
     print("hello")
  fun1()
  fun1()
  
  
  
  1000 times----------->O(1)  
  
  
  def fun(n):
      if n==0:
	     return 1
	  else:
	     return fun(n-1)
   fun(5)
   
   n=5---------->6 function calls
   n=10--------->11 function calls
   
   n=n---------->n+1 function
   
   T(n)=n+1----->O(n)
   
   
   def fun(n):---->T(n)
      if n==0:----->1unit
	     return 1---->1 unit
	  else:
	     return fun(n-1)--->T(n-1)
   fun(5)---.1unit
   
   T(n)=T(n-1)+3
   T(n)=T(n-1)+1----------(1)
   put n=n-1 in eq (1)
   
   T(n-1)=T(n-2)+1-------(2)
   
   put eqn (2) in eqn (1)
   
   T(n)=T(n-2)+1+1
   T(n)=T(n-2)+2
   
   
   
   -----
   
   T(n)=T(n-k)+k
   
   put n-k=0
   -k=-n---->k=n----
   T(n)=T(0)+n
   T(n)=1+n----
   T(n)=O(n)---->back substitution method 
   
  2.
   def fun1(n):
      if n==0 or n==1:
	      return 1
	  else:
	      return n*fun1(n-1)
		  
		  
	fun1(5)
	
	n=5----->n*fun1(4)
	         n=4-------->n*fun1(3)
			     n=3---->n*fun1(2)
				   n=2------------>n*fun1(1)
	n=5-------->fun calls-->5
	
	n=n-------->n--->O(n)
	
	
	3.def fun3(n):
	    if n==0 or n==1:
		    return 1
	    else:
		    return fun3(n-1)+fun3(n-2)
	
		Recursion Tree.....O(2^n)-->exponential times-----------
		
		
	4.def fun4:
	    if n==0:
		   return 1
		else:
		   return fun4(n-1)*(n-1)
		   
		   
	5.
	   def fun(a,b):
	      if b==0:
		     return 0
		  else:
		     return a+fun(a,(b-1))
			 
			 
	a=2,b=5
	
	    a+fun(a,4)
		    a+a+fun(a,3)
			   a+a+a+fun(a,2)
			       a+a+a+a+fun(a,1)
				        a+a+a+a+a+fin(a,0)
	b=5-------->FC=5
	b=n------->Fc=n--->O(n)
			 
			 
	6. def fun(n):
	     if n==0:
		     return 1--->1unit
		 elif n%2==0:
		     res=fun(n//2)
			 return res*res--->T(n/2)
		 else:
		     res=fun(n//2)
			 return res*res+1---->T(n/2)
			 
		n=4------>4%2==0-->True
		   n=2--->2%2==0--->True
		   n=1---->1%2=!0-->False
		   
		   n=0----.
		   
		   T(n)=T(n/2)+1---(1)
		   
		   
		   T(n)=O(log(n))
		   
		   
	def fun(lst,low,high,key):
	    if low>high:
		    return -1
	    mid=low+high//2
		if lst[mid]==Key:
		    return 1
		elif lst[mid]<key:--------------->T(n/2)
		   return fun(lst,mid+1,high,key)
		else:
		   return fun(lst,low,mid,key)----->T(n/2)
		   
		   
		   T(n)=T(n/2)+1--->O(logn)  
		   
		   
	def fun1(n):
	    if n==0:
		   return 0
		   
		else:
		    print(n%2)
			fun1(n//2)
	fun1(9)
	
	
	
	def fun1(n):
	    if n==0:
		   return 0
		   
		else:
		    
			fun1(n//2)
			print(n%2)
	fun1(9)
		   
		space complexity:
		
		for a recursive code:
		space complexity=size of the stack
		
		sc=O(logn)
		
		
	def fun(n):
      if n==0:
	     return 1
	  else:
	     return fun(n-1)
   fun(5)----------------->T.C=O(n)
                           S.C=O(n)
						   
						   
	def fun(a,b):
	      if b==0:
		     return 0
		  else:
		     return a+fun(a,(b-1))
			 
			 
Numpy Broadcasing:
		
		
	